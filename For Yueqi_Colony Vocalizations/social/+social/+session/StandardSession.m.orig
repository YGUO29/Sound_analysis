classdef StandardSession < social.interface.Social
    %SessionLog - The StandardSessionLog stores all information related to 
    % a standard vocalization recording session, typically including a 
    % target and reference microphone. A StandardSessionLog may include
    % neurophysiology data recorded with nvr, DAQ_Record, MANTA, or MCS.
    %   
    % Written by Seth Koehler and Lingyun Zhao, 3/2015.
    
    properties %DEBUG(Access = protected)
        SessionID       %
        Headers         % Must contain one or more SessionLogFile objects.
        Signals         % An array of signal objects, can include both raw and computed signals.
        BehChannels     % An array of BehaviorChannel objects, enumerates exp defined behaviors based on one or more recorded signals
        Events          % An array of event objects, can include both discrete and continuous events.
        SyncTime        % Identifies the session time to which all events are referenced.
        Time            % Absolute time and date of beginning and end of session.
    end
    
    properties 
        ID              % An array of subject IDs, always in the form M*.
        Experimenter    % Experimenter's name
        Experiment      % Experiment name/type
        Environment     % Recording location
    end
    
    properties 
        DataPath = '\'; % Think a
    end
    
    methods
        % Construct a SessionLog object.
        function self=StandardSession(filename)
            % Construct StandardSession object given relative path and
            % filename of a digivoc style *.hdr file written by mvx and
            % DAQ_record.
            if nargin==0
                return;
            end
            % Load first header
            self.Headers=social.session.SessionFile(filename);
            
            % Find related headers
            
            % Determine SessionID
            %TODO Figure out best way to format sessionIDs.  For now, use
            %M##S###.
            temp=strsplit(self.Headers.Header.animal,'_');
            if temp{1}(1)~='M'
                temp{1}=['M' temp{1}];
            end
%             self.SessionID=[temp{1} '_S' num2str(self.Headers.Header.session)];
            %For now, stick with the recorded filename.
            [p,f,e]=fileparts(self.Headers.File);
            self.SessionID=f;

            % Find related microphone signal files
            % Assume that they are stored in the first set of channels.
            ch_set=1;
            [p,f,e]=fileparts(self.Headers.File);
            filename=fullfile(p,[f '.wav']);
            for i=1:self.Headers.Header.nch(ch_set)
                temp_hdr=self.Headers.Header.ch{ch_set}{self.Headers.Header.chlist{ch_set}(i)};
<<<<<<< local
                if ismember('animal',fieldnames(temp_hdr))
                    self.Signals{i}=social.signal.StandardVocalSignal(filename,temp_hdr.animal,i);
                else
                    self.Signals{i}=social.signal.StandardVocalSignal(filename,['M' num2str(i)],i);
                end
=======
                
                % if animal name is not available for each channel, use the
                % one for the one specified by the session
                if isprop(temp_hdr,'animal')
                    self.Signals{i}=social.signal.StandardVocalSignal(filename,temp_hdr.animal,i);
                else
                    self.Signals{i}=social.signal.StandardVocalSignal(filename,self.Headers.Header.animal,i);
                end
>>>>>>> other
            end
            self.Signals=[self.Signals{:}];
            [self.Signals.SessionID]=deal(self.SessionID);
            
            % initialize BehChannels
%             self.BehChannels = social.channel.RegularVocalChannel;
        end
        
        % Return a list of events.
        function events = GetEvents(self,varargin)
        % Return an array of event objects, given a list of parameter/value
        % pairs. For example:
        %   session.GetEvents('eventClass','Call','callType','Phee');
        % Event filters will be applied in the order they are supplied,
        % allowing filters to pull out subsets of different event classes
        % (such as Calls and then call types as in the example above.
        % GetEvents relies on ismember, so it will work with any properties
        % for which ismember can be used.
        
        % Figure out what types of events to include in the event array.
            if isempty(varargin)
                events=self.Events;
                return;
            end
            for i=1:length(varargin)./2
                prop_name{i}=varargin{i.*2-1};
                prop_val{i}=varargin{i.*2};
            end
            events=self.Events;
            for i=1:length(prop_name)
                vals={events.(prop_name{i})}';
                events=events(ismember(vals,prop_val{i}));
            end
        end
        
        % Return an array of signal objects
        function signals = GetSignals(self,varargin)
            if isempty(varargin)
                signals=self.Events;
                return;
            end
            for i=1:length(varargin)./2
                prop_name{i}=varargin{i.*2-1};
                prop_val{i}=varargin{i.*2};
            end
            signals=self.Signals;
            for i=1:length(prop_name)
                vals={signals.(prop_name{i})}';
                signals=signals(ismember(vals,prop_val{i}));
            end
        end
        
        % Return a table structure containing the requested information.
        function table=Tabulate(self)
        end
        
        % Return a formatted report summarizing session information.
        function str=Report(self)
            % Report returns a nx1 cell string array summarizing the data
            % included in the session.
            
            str{1} = ['Session: ' self.SessionID];
            
            %
        end
        
        %%%% SYNCHRONIZATION
        function success=updateSyncTime(self,synctime)
            try
                self.SyncTime=synctime;
                for i=1:length(self.Signals)
                    self.Signals(i).SyncTime=synctime;
                end
                for i=1:length(self.Events)
                    self.Events(i).updateSyncTime(synctime);
                end
                success=true;
            catch
                success=false;
            end
        end
        
        function plotEvents(self,varargin)
            % Function to plot events.  Supply Parameter,Value pairs to
            % control plotting. Uses social.utils.timeline.m for plotting.
            % 'ah' - supply axis handle
            if isempty(self.Events)
                return;
            end
            
            p=inputParser;
            addParameter(p,'fig',figure)
            p.parse(varargin{:});
            fh=p.Results.fig;
            
            %Prepare axis
%             ah.NextPlot='replace';
            clf(fh);
            names=unique({self.Events.Name});
            subset={'Calls','Phrases'};
            for i=1:length(names)
                    sel_phrases=self.Events(ismember({self.Events.Name},names{i}));
                    sel_phrases=sel_phrases(ismember({sel_phrases.eventClass},'Phrase'));
                    sel_calls=self.Events(ismember({self.Events.Name},names{i}));
                    sel_calls=sel_calls(ismember({sel_calls.eventClass},'Call'));
                    tags{i.*2-1}=[names{i} '-Calls'];
                    t_start{i.*2-1}=[sel_calls.eventStartTime];
                    t_stop{i.*2-1}=[sel_calls.eventStopTime];
                    tags{i.*2}=[names{i} '-Phrases'];
                    t_start{i.*2}=[sel_phrases.eventStartTime];
                    t_stop{i.*2}=[sel_phrases.eventStopTime];
            end
            figure(fh);
            social.util.timeline(tags,t_start,t_stop);
            ah=gca;
            ah.XLim=[0 self.Events(1).Header.Duration];
        end
        
        function sort_events(self,varargin)
            % sort_events([property,direction]) sorts events by the
            % supplied property name (as a string) and direction ('ascend'
            % or 'descend'.  If direction is not supplied, 'ascend' is
            % defult'.  If property is not supplied, then 'eventStartTime'
            % is default.
            a=struct;
            p=inputParser;
            addOptional(p,'property','eventStartTime',@checkproperty)
            addOptional(p,'direction','ascend',@checkdirection)
            parse(p,varargin{:})
            property=p.Results.property;
            direction=p.Results.direction;
            
            % Extract property values
            if isempty(self.Events)
                return;
            elseif iscell(self.Events(1).(property))
                val={self.Events.(property)}; val=reshape(val,numel(val),1);
                % sort by direction
                [a.b,a.i]=sort(val);
            else
                val=[self.Events.(property)]; val=reshape(val,numel(val),1);
                % sort by direction
                [a.b,a.i]=sort(val,1,direction);
            end
            
            % Reorder events by indices list
            self.Events=self.Events(a.i);
            
            function output=checkproperty(input)
                prop_names=properties(self.Events);
                if ~any(ismember(input{2},prop_names))
                    error('Property must be an event property.')
                else
                    output=true;
                end
            end
            function output=checkdirection(input)
                if ~isstr(input{2})
                    error('Direction must be a string.');
                else
                    input{2}=lower(input{2});
                    if ~any(ismember({'ascend','descend'},input{2}))
                        error('Direction must either ascend or descend.');
                    else
                        output=true;
                    end
                end
            end
                
            
        end
        
        function success=saveSession(self,varargin)
            try
                
                if nargin>1
                    p=varargin{1};
                else
                    [p]=fileparts(self.Headers(1).File);
                end
                filename=fullfile(p,['Session_' self.SessionID '.mat']);
%                 while exist(filename,'file')==2
%                     i=i+1;
%                     filename=fullfile(p,[f '-ver' sprintf('%03d',i) '.mat']);
%                 end
                eval([self.SessionID '=self;'])
                save(filename,self.SessionID);
                success=true;
            catch
                success=false;
            end
        end
        
        function ManageBehChannel(self)
            % make a GUI here: add, browser, edit, delete, etc
            social.channel.ManageBehChGUI(self)
        end
        
        function DetectBehEvent(self,ind_beh_ch)
            % for detecting behavioral events in one BehaviorChannel
            % indexed by ind_beh_ch
           
            detected_events = self.BehChannels(ind_beh_ch).DetectEvents(self);
            
            self.Events = [self.Events, detected_events];
        end
        
        function DetectAllBehEvents(self)
            for i = 1:length(self.BehChannels)
                self.DetectBehEvent(i);
            end
        end
    end
end

